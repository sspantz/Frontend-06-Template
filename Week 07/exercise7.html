<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Realm Object Visualization</title>
    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.5.10/dist/g6.min.js"></script>
  </head>
  <body>
    <div id="container" style="width: 100%; height: 100%"></div>
    <script>
      function getRealm() {
        let map = new Map();
        let set = new Set();
        let objectNames = [
          "eval",
          "isFinite",
          "isNaN",
          "parseFloat",
          "parseInt",
          "decodeURI",
          "decodeURIComponent",
          "encodeURI",
          "encodeURIComponent",
          "Array",
          "Date",
          "RegExp",
          "Promise",
          "Proxy",
          "Map",
          "WeakMap",
          "Set",
          "WeakSet",
          "Function",
          "Boolean",
          "String",
          "Number",
          "Symbol",
          "Object",
          "Error",
          "EvalError",
          "RangeError",
          "ReferenceError",
          "SyntaxError",
          "TypeError",
          "URIError",
          "ArrayBuffer",
          "SharedArrayBuffer",
          "DataView",
          "Float32Array",
          "Float64Array",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Uint8Array",
          "Uint16Array",
          "Uint32Array",
          "Uint8ClampedArray",
          "Atomics",
          "JSON",
          "Math",
          "Reflect",
        ];

        objectNames.forEach(name => map.set(name, window[name]));

        let realm = {
          id: "realm",
          children: objectNames.map(name => ({
            id: name,
            children: [],
          })),
        };

        let realmChildrenQueue = [...realm.children];

        while (realmChildrenQueue.length) {
          let child = realmChildrenQueue.shift();
          let id = child.id;
          let object = map.get(id);

          if (set.has(object)) continue;
          set.add(object);

          for (const prop of Object.getOwnPropertyNames(object)) {
            let d = Object.getOwnPropertyDescriptor(object, prop);

            const pushChild = (type = "value") => {
              let childId =
                type === "value" ? `${id}.${prop}` : `${id}.${prop}.[${type}]`;

              let o = {
                id: childId,
                children: [],
              };
              map.set(childId, d[type]);
              child.children.push(o);

              realmChildrenQueue.push(o);
            };

            if (
              (d.value !== null && typeof d.value === "object") ||
              typeof d.value === "function"
            ) {
              pushChild();
            }
            if (d.get) pushChild("get");
            if (d.set) pushChild("set");
          }
        }
        return realm;
      }

      function render(data) {
        const width = document.getElementById("container").scrollWidth;
        const height = document.getElementById("container").scrollHeight || 500;
        const graph = new G6.TreeGraph({
          container: "container",
          width,
          height,
          modes: {
            default: [
              {
                type: "collapse-expand",
                onChange: function onChange(item, collapsed) {
                  const data = item.get("model").data;
                  data.collapsed = collapsed;
                  return true;
                },
              },
              "drag-canvas",
              "zoom-canvas",
            ],
          },
          defaultNode: {
            size: 26,
            anchorPoints: [
              [0, 0.5],
              [1, 0.5],
            ],
            style: {
              fill: "#939f5c",
              stroke: "#d16014",
            },
          },
          defaultEdge: {
            type: "cubic-horizontal",
            style: {
              stroke: "#bbce8a",
            },
          },
          layout: {
            type: "mindmap",
            direction: "H",
            getHeight: () => {
              return 16;
            },
            getWidth: () => {
              return 100;
            },
            getVGap: () => {
              return 10;
            },
            getHGap: () => {
              return 100;
            },
            getSide: () => {
              return "right";
            },
          },
        });

        let centerX = 0;
        graph.node(function (node) {
          if (node.id === "Modeling Methods") {
            centerX = node.x;
          }

          return {
            label: node.id,
            labelCfg: {
              position:
                node.children && node.children.length > 0
                  ? "right"
                  : node.x > centerX
                  ? "right"
                  : "left",
              offset: 5,
            },
          };
        });

        graph.data(data);
        graph.render();
        graph.fitView();
      }

      render(getRealm());
    </script>
  </body>
</html>
